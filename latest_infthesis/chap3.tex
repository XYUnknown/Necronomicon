% begin patch To deal with latex problem typesetting ! in listing environment
\newcommand*\bang{!}
% end patch

\Chapter{Oxidising Remote Procedure Calls}{A Universal Method Invocation Library for Rust}
\label{chap3}

\begin{tikzpicture}[color=black,
                   transform shape,
                   every node/.style={inner sep=0pt}]
% \node[minimum size=\framesize,fill=white](vecbox){};
% \node[text width=\framesize,align=center](Text){%
%     `Then you should encode what you mean', the March Hare went on.
% \\
% `I do', Programmer hastily replied; `at least --- at least I mean what I encode --- that's the same thing, you know.'
% \\
% `Not the same thing a bit', said the Hatter.};
\node[minimum width=\framesize, minimum height=0.60 *\framesize, fill=white](vecbox){};
\node[anchor=north west] at (vecbox.north west){% 
\pgfornament[width=0.1*\framesize]{61}};
\node[anchor=north east] at (vecbox.north east){% 
\pgfornament[width=0.1*\framesize,symmetry=v]{61}};
\node[anchor=south west] at (vecbox.south west){% 
\pgfornament[width=0.1*\framesize,symmetry=h]{61}};
\node[anchor=south east] at (vecbox.south east){% 
\pgfornament[width=0.1*\framesize,symmetry=c]{61}};
\node[anchor=north] at (vecbox.north){% 
\pgfornament[width=0.25*\framesize]{88}
% \pgfornament[width=0.1*\framesize]{15}
% \pgfornament[width=0.1*\framesize]{16}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
};

\node[anchor=south] at (vecbox.south){% 
% \pgfornament[width=0.25*\framesize]{88}
% \pgfornament[width=0.1*\framesize,symmetry=h]{15}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
% \pgfornament[width=0.1*\framesize,symmetry=h]{16}
% \pgfornament[width=0.25*\framesize]{88}
};
% \node[anchor=south] at (vecbox.south){% 
% \pgfornament[width=0.6*\framesize]{46}};
% \node[anchor=north,rotate=90] at (vecbox.west){% 
% \pgfornament[width=0.6*\framesize,symmetry=h]{46}};
% \node[anchor=north,rotate=-90] at (vecbox.east){% 
% \pgfornament[width=0.6*\framesize,symmetry=h]{46}};
\node[text width=0.85\framesize,align=justify] at (vecbox.center){%
The building is circular. The apartments of the prisoners occupy the circumference. You may call them, if you please, the cells. The apartment of the inspector occupies the centre, you may call it if you please the inspector’s lodge. To cut off from each prisoner the view of every other, the partitions are carried on a few feet beyond the grating into the intermediate area, such projecting parts I call the protracted partitions. These windows of the inspector’s lodge open into the intermediate area, in the form of doors, in as many places as shall be deemed necessary to admit of his communicating readily with any of the cells. \\
\rightline{--- Jeremy Bentham ``Panopticon or the Inspection-House"}};
\end{tikzpicture}

\section{Prologue}
\label{chap3:prologue}
In chapter~\ref{chap1}, we have briefly discussed the conceptual question that we would like to ask: How to intuitively understand \emph{distributed programs} using the same conceptual model as \emph{monolithic programs}? It would be beneficial to view a monolithic programs as an abstraction of distributed program, specifying the intended behaviours of the invocations and resource usage in the distributed program while abstracting away message-passing details, since it would make the process of migrating monolithic programs into a distributed setting straightforward and simplify the process of implementing a distributed system.

In this chapter, we discuss in detail our design, implementation and formalisation of a universal invocation (UMI) library in Rust, which supports location transparency, allowing a monolithic program to be migrated into a distributed design with minimal syntactic modification and preserves the semantics of the original program.

As a metaphorical illustration, the core idea of our attempt for conceptually modelling and understanding distributed programs as monolithic programs resembles a \emph{panopticon}, where the distributed resource management is governed by a monolithic design of Rust's ownership and borrow checking system.

\section{Introduction}
\label{chap3:introduction}
Distributed computing has extensive application in areas such as cloud computing, big data processing, web services, and blockchain systems, driving the development of modern, large-scale, and resilient software systems. It offers significant advantages such as scalability, fault tolerance, resource sharing, and geographical distribution.


In summary, we make following contributions:
\begin{itemize}
    \item We provide a usable \emph{Rust implementation of the UMI framework}.
    \item We formalise the \emph{structural operational semantics} for a core calculus of monolithic and distributed Rust programs.
    \item We prove a \emph{location transparency theorem}: With the UMI framework, when a monolithic program is deployed to multiple nodes, its semantics is preserved.
\end{itemize}

\section{Background}
\label{chap3:background}
In distributed computing, a remote procedure call (RPC) allows a method invocation to be executed on another computer on a shared network. One application of RPC is that in an object-oriented programming paradigm, it enables a method to be invoked on an object stored on a different machine and exchange data across the network. Such a remote method invocation has the same coding as a local invocation, without the programmer explicitly coding the details for the remote interaction.
However, it is hard to support \emph{location transparency}, i.e., in most existing frameworks (e.g., Java RMI), remote invocations do not have \emph{the same semantics} as local invocations. In addition, \emph{memory management} is hard in a distributed setting, for example, distributed garbage collection is complicated.

Rust is high-level system programming language which \emph{guarantees memory safety} and \emph{prevents data races} by its \emph{ownership} rules for memory management and \emph{borrow checker} for tracking object lifetime of all references in a program during compilation.
Since Rust has semantics that guarantees memory safety, we can extend such guarantees to the distributed computing setting, allowing us to design a RPC framework that provides safe remote method invocations.

\subsection{Remote Procedure Calls}
\label{chap3:background:rpc}
A RPC allows a computer program to request a service from another program located in a different address space, which could be on the same machine or on a different machine across a network. It is a form of client-server communication, where the requesting program is the client, and the service-providing program is the server.

The basic idea behind RPC is to make a remote procedure call seem like a local procedure call, abstracting away the underlying communication mechanisms and network protocols and simplifying distributed computing by providing a familiar programming model. The client program calls a procedure, and the RPC system handles the task of transferring the procedure call request to the remote server, along with any necessary parameters or data. The server then executes the requested procedure and sends the results back to the client.

RPC is particularly useful in distributed systems, where different components of an application are running on separate machines or processes. It allows these components to communicate and share resources efficiently, as if they were part of a single program. There are many common applications of RPC. For example, in distributed file systems, RPC is used in distributed file systems, such as Network File System (NFS), to enable clients to access and manipulate files on remote servers transparently. In remote database access, RPC facilitates remote access to databases, allowing client applications to execute queries and retrieve data from remote database servers. In designing web services, RPC forms the basis of many web service protocols, such as SOAP (Simple Object Access Protocol), which allows applications to communicate over the internet using XML-based messaging. In modern microservices architectures, RPC is often used for inter-process communication between different microservices, enabling them to collaborate and share functionality. In object-oriented programming, RPC enables objects on different machines to interact with each other, invoking methods and passing data across the network, which is the application domain that we focus on in this study.

\subsection{Rust}
\label{chap3:background:rust}
As a system programming language emphasising on safety, performance, and concurrency, Rust is designed to prevent common programming errors, such as dereferencing null pointers and data races. Rust achieves these goals through its unique features of ownership, borrow checking, and lifetimes.

In Rust, each value has a variable known as its \emph{owner}. Each value can only have one owner at a time, and when the owner goes out of scope, the value is dropped. This ownership model ensures that resources are managed correctly without the need for a garbage collector (cite rust lang). The ownership system is fundamental to Rust and serves as the basis for its memory safety.

Rust allows functions and data structures to borrow references to values without taking ownership. This is called \emph{borrowing}. When a value is borrowed, the original owner cannot modify the value until the borrowing ends. The \emph{borrow checker} is part of Rust's compiler, which ensures that references are used safely and do not result in dangling pointers or other memory issues. Borrowing can be either mutable or immutable, but mutable references have additional constraints to prevent data races and undefined behaviours.

Lifetimes in Rust express how long references should be valid. They assist the borrow checker in ensuring that references do not outlive the data they point to. Rust uses lifetimes to prevent dangling references, which is vital for memory safety. Lifetimes are explicitly stated or inferred, and they work alongside ownership and borrowing to maintain safety and prevent data races.

The combination of ownership, borrowing, and lifetimes allows Rust to enforce strict memory safety without requiring a garbage collector. These features prevent common bugs and ensure that Rust programmes are free of data races. Memory safety means that all references point to valid memory, and data races are avoided by allowing only one mutable reference at a time or multiple immutable references.

\section{The Implementation of Rust UMI Library}
\label{chap3:implementation}
In the section, we present our implementation of a universal method invocation (UMI) library in Rust. With such a library, a monolithic program can be migrated into a distributed program while preserving the semantics of the monolithic program.

\subsection{Overview}
\label{chap3:impl:overview}
To give a high-level overview of the design, in figure~\ref{impl:simple-example}, we introduce an example of migrating a monolith application into a distributed setting. In this example, the \emph{macro} \texttt{\#[proxy\_me]} implicitly translates the declared type \texttt{A} from a \texttt{struct} that can only refer to local resources to an \texttt{enum} that can either hold local resources or be a \emph{proxy} that refers to remote resources. The initialisation method is translated by the macro \texttt{\#[umi\_init]} to create an instance of the \texttt{enum} \texttt{A} instead of an instance of the \texttt{struct} \texttt{A}. Other methods are also translated by macros to allow both an invocation on a local instance of \texttt{A} and an invocation on a proxy of \texttt{A}. To create a proxy instance, the macro \texttt{remote!(address, ...)} is used, while the syntax of the initialisation of a local variable is unchanged. The invocations of the methods defined for translated \texttt{struct} \texttt{A} take the same form of the invocation those original methods.

An invocation on a proxy is encapsulated in to a serialised message and sent to a receiving node of which the address is the address of the proxy, and then the message is deserialised and the invocation is executed at the destination. After the execution, the result of the is again put into a serialised message and passed back to the calling node to be deserialised.
\begin{lstlisting}[language=Rust, style=boxed]
#[proxy_me]
struct A { arg: u32 }
impl A {
  #[umi_init]
  new(arg: u32) -> A { A {arg: arg} }
  #[umi_struct_method]
  foo1(&self, a: A) {/* do something */}
  #[umi_struct_method]
  foo2(&self, &a: A) {...}
  #[umi_struct_method]
  foo3(&self, &mut a: A) {...} .....
}
\end{lstlisting}
\begin{lstlisting}[language=Rust, style=boxed]
fn main() {
  let a_remote = remote!\bang!(addr, A::new(10));
  
  let a_local1 = A::new(1);
  let a_local2 = A::new(2);
  let mut a_local3 = A::new(3);
  
  a_remote.foo1(a_local1);
  a_remote.foo2(&a_local2);
  a_remote.foo3(&mut a_local3);
}
\end{lstlisting}

\subsection{The Design of the Translation}
\label{impl:proxy}
In the example discussed in section~\ref{chap3:impl:overview}, the syntax is translated by macros. For a declared \texttt{struct}, the macro \texttt{\#[proxy\_me]} performs the translation:
\[
\texttt{struct}\; A\;\{\; \mathit{fields}\;\} \leadsto \texttt{enum}\; A\;\{\; \mathit{Local}\;(\;\mathit{fields}\;), \mathit{Remote}\;(\;\mathit{Address}, \mathit{ID}, \mathit{IsOwner}\;)\;\} 
\]
where the \textit{Address} is the address of the node which stores the resource of a proxy, \textit{ID} is the identifier of a proxy's resource in the resource table discussed in section~\ref{impl:resource} and \textit{IsOwner} denotes if a proxy is a owned reference or a borrow reference.
This macro can also translate an \texttt{enum} to allow it to represent a proxy by adding a new variant which is the proxy:
\[
\texttt{enum}\; A\;\{\; \mathit{variants}\;\} \leadsto \texttt{enum}\; A\;\{\; \mathit{variants}, \mathit{Remote}\;(\;\mathit{Address}, \mathit{ID}, \mathit{IsOwner}\;)\;\} 
\]
The translation of a \texttt{enum} does not affect its initialisation method, however, the translation of a \texttt{struct} requires its initialisation method to be changed accordingly --- instead of creating an instance of a type which is a \texttt{struct}, an instance of a \textit{Local} variant of an \texttt{enum} is created. For instance, in the example shown in figure~\ref{impl:simple-example}, the \texttt{new(arg: u32)} method is translated by \texttt{\#[umi\_init]} into:
\begin{lstlisting}[language=Rust, style=boxed, basicstyle=\footnotesize\ttfamily]
  new(arg: u32) -> A { A::Local {arg: arg} }
\end{lstlisting}

The macro \texttt{\#[umi\_struct\_method]} performs the translation of other methods of a \texttt{struct}. For instance, the method \texttt{foo1(\&self, a: A)} is translated into:
\begin{lstlisting}[language=Rust, style=boxed, basicstyle=\footnotesize\ttfamily]
  fn foo1(&self, a: A) {
    match &self {
      Local(...) => { /* do something */ },
      Remote(...) => { /* remote do something */ }
  }}
\end{lstlisting}
As for a method of a translated \texttt{enum}, the macro \texttt{\#[umi\_enum\_method]} adds an additional pattern matching for the proxy invariant to the existing pattern matching.

\subsection{Resource Management}
\label{impl:resource}
To be able to use the UMI library for executing programs that access and manipulate memories of different nodes of a network, resources and computations need be made available to and well-managed by all nodes in the network.

Firstly, a node should be able to store resources owned by difference machines and deallocate those resources according to the their lifetime.
In Rust, if some resources are owned by a reference on the same node, and the reference has reach the end of its lifetime, these resources will be deallocated from the memory. With such a design, resources that are not owned by any reference on the same node are automatically deallocated. However, in our UMI library, some resources on a node $n_1$ might be owned by reference on a different node $n_2$. While these resources does not have a local owner, the deallocation should not happen until the remote owner reaches the end of its lifetime. To achieve this, on each UMI server, we use a table shown in figure~\ref{impl:tables} with the same lifetime of the server to identify and manage local resources involved in remote computations. Note that the \textit{ID} is a part of the corresponding proxy.
If a variable is created locally, it will be put into the table once it is passed into a remote computation. The entry will not be removed until the remote computation finishes. If a variable is created via a remote call, it will be put into table on creation and will be deallocated when its remote owner decides that it should be dropped.
\begin{figure}
\centering
\begin{tabular}{ |c|c| } 
\hline
\textbf{ID} & \textbf{Resource} \\\hline
0 & ... \\\hline
1 & ... \\\hline
... & ... \\
\hline
\end{tabular}
\quad
\begin{tabular}{ |c|c| } 
\hline
\textbf{Full Path Name} & \textbf{Type Information} \\\hline
\texttt{A::new} & \texttt{u32}, \texttt{A} \\\hline
\texttt{A::foo1} &  (\texttt{\&A}, \texttt{A}), \texttt{()} \\\hline
... & ... \\
\hline
\end{tabular}
\caption{Resource table (L) and registration table (R)}
\label{impl:tables}
\end{figure}

Secondly, to make computations available on all nodes, all methods that can be invoked on a proxy should be registered in a method registration table shown in figure~\ref{impl:tables} by a \texttt{register!(name, arg\_types, return\_type)} macro. The registration table holds the full path name, argument types and return type of the method. When a serialised invocation message, which takes the form of a plain string, received by a node, the method is deserialised and reconstructed according to the type information recorded in the registration table.

\subsection{Passing Remote Invocations via Messages}
\label{impl:message}
As briefly discussed in section~\ref{impl:overview} and section~\ref{impl:resource}, remote invocations and results of executions are communicated via serialised and deserialised messages among nodes. We make use of the Serde \citep{serde} framework to serialise and deserialise these messages and Rust data structures.

There are different types of messages for passing remote invocations. For instance, a remote invocation sent to an receiving node is represented as an invocation message which taking the form of \texttt{Message::Invoke(fname, variables, invoke\_op)}, where \texttt{fname} is the full path name of the method, each variable is annotated with its ownership information (owned or immutably/mutably borrowed) and \texttt{invoke\_op} specifies the ownership information of the return value. The result of the execution of an remote invocation is passed to the calling node via a return message in the form of \texttt{Message::Return(return\_var)}, where the \texttt{return\_var} is also annotated with its ownership information. Another important type of message is the deallocation messages which takes the form of \texttt{Message::Drop(id)}, where the \texttt{id} corresponds to an entry key in the resource table shown in figure~\ref{impl:tables}. Such a message instructs some remotely owned resources to be deallocated.

\subsection{Extending Borrow Checking Guarantees into the Distributed Setting}
\label{impl:borrow}
To execute a deserialised remote invocation on a receiver, the first step is to gather serialised variable data as well as the ownership information of each variable. In this step, we do not perform any reconstruction of these variables, instead, variables are simply prepared in an appropriate format that can be reconstructed during the execution of the method. The implementation of such a process is shown in listing~\ref{impl:invoke}.

A serialised variable is labelled to indicate that if it is a piece of data copied or moved from the caller (\texttt{OwnedLocal}), a remote reference owned by the caller (\texttt{OwnedRemote}), a remote reference immutably borrowed by the caller (\texttt{RefRemote}) or a remote reference mutably borrowed by the caller (\texttt{MutRefRemote}). 
If a variable is serialised data, it will be kept as serialised, since the deserialisation and reconstruction will happen during the invocation of the method. 
If a variable is a proxy which is located at the receiver, then it will be obtained from the resource table shown in figure~\ref{impl:tables}. According to its ownership information, if it is moved, then the corresponding entry will be removed from the resource table. 
If it is immutably borrowed, then the corresponding entry will be immutably borrowed from the table and if it is mutably borrowed, then the corresponding entry will be mutably borrowed from the table and updated after the execution. 
If an argument is a proxy that is not located at the caller, then the proxy will be passed into the method without any additional change.

\begin{lstlisting}[language=Rust, style=boxed, basicstyle=\footnotesize\ttfamily, caption={Gathering variables from an invocation message}, label=impl:invoke]
Message::Invoke(fname, variables, invoke_op) => {
  let mut arguments: Vec<Argument> = Vec::new();
  for v in &variables {
    match v {
      Variable::OwnedLocal(s) => { arguments.push(Argument::Serialised(s.clone())); },
      Variable::OwnedRemote(serialise_remote, addr, id) => {
        if addr == &local_address {
          let (owned, is_ref) = mvtable.remove(id).unwrap().into_inner();
          let arg_ref = Argument::Owned(owned);
          arguments.push(arg_ref);
        } else { arguments.push(Argument::Serialised(serialise_remote.to_string())); }
      },
      Variable::RefRemote(serialise_remote, addr, id) => {
        if addr == &local_address {
          let borrow = mvtable.get(id).unwrap().borrow();
          let ptr: *const (Box<dyn Any + Send + Sync>, bool) = &*borrow;
          unsafe {
            let back: &(Box<dyn Any + Send + Sync>, bool) = ptr.as_ref().unwrap();
            let arg_ref = Argument::Ref(&back.0, back.1);
            arguments.push(arg_ref); }
        } else { arguments.push(Argument::RemoteRef(serialise_remote.to_string())); }
      },
      Variable::MutRefRemote(serialise_remote, addr, id) => {
        if addr == &local_address {
          let mut borrow_mut = mvtable.get(id).unwrap().borrow_mut();
          let ptr: *mut (Box<dyn Any + Send + Sync>, bool) = &mut *borrow_mut;
          unsafe {
            let back: &mut (Box<dyn Any + Send + Sync>, bool) = ptr.as_mut().unwrap();
            let arg_ref = Argument::MutRef(&mut back.0, back.1);
            arguments.push(arg_ref); }
        } else { arguments.push(Argument::RemoteMutRef(serialise_remote.clone())); }
  }}}
  ...
}
\end{lstlisting}

Once the information of all variables are gathered and processed, the invocation can be executed and the result will then be sent back to the caller. The implementation of such operations are shown in listing~\ref{impl:exec-return}. The method data, mainly ownership and type information of the arguments and return value of a method are retrieved from the registration table shown in figure~\ref{impl:tables}. During the execution of the method via \texttt{f.call(arguments)}, serialised arguments and boxed argument entries retrieved from the resource table are reconstructed according to the registered type information.

The result of an execution is provide in two format, serialised data and a boxed data entry. These two formats are used according to the required ownership information of the return value. If the method produces an owned result annotated with \texttt{InvokeOp::Owned}, no matter the serialised data \texttt{res} is some local resources or a proxy, it will be kept as the serialised form and sent back via a return message. If the method is an initialisation call sent by the macro \texttt{remote!(...)} annotated with \texttt{InvokeOp::Init}, the boxed entry data will be inserted into the resource table and an unique \texttt{id} will be generated. In the return message, the address of the receiver, the \texttt{id}, and the ownership status which is \texttt{true} are included for the caller to construct a proxy that owns such a data entry on the receiver. For a return value that is an immutably or mutably borrowed reference, there are two situations. If the borrowed reference is local to the receiver, the reference itself will be inserted into the resource table identified by an generated unique \texttt{id}. Such an \texttt{id} and the address of the receiver will be sent back to the caller for creating an proxy that mirrors this borrowed reference. However, if a borrowed reference is not local to the receiver, meaning it already mirrors a reference on a different node, then it will not be stored in the resource table, instead, the serialised version of it will be sent back to the caller in a return message.
\begin{lstlisting}[language=Rust, style=boxed, basicstyle=\footnotesize\ttfamily, caption={Executing an invocation and returning the result}, label=impl:exec-return]
Message::Invoke(fname, variables, invoke_op) => {
  ...
  let f: &str = &*fname; 
  match lrtable.get(f) {
    Some(f) => {
      let ((res, is_local), b) = f.call(arguments);
      let res_message: Message;
      match invoke_op {
        InvokeOp::Owned => { res_message = Message::Return(ReturnVar::Owned(res)); },
        InvokeOp::Init => {
          let id = (SystemTime::now(), m_id_gen.next());
          mvtable.insert(id.clone(), RefCell::new((b, false))); // b is the resource
          res_message = Message::Return(ReturnVar::OwnedInit(local_address, id, true));
        },
        InvokeOp::Ref => {
          if is_local {
            let id = (SystemTime::now(), m_id_gen.next());
            mvtable.insert(id.clone(), RefCell::new((b, true))); // b is a reference
            res_message = Message::Return(ReturnVar::RefMirror(local_address, id));
          } else { res_message = Message::Return(ReturnVar::RefBorrow(res)); }
        },
        InvokeOp::MutRef => {
          if is_local {
            let id = (SystemTime::now(), m_id_gen.next());
            mvtable.insert(id.clone(), RefCell::new((b, true))); // b is a reference
            res_message = Message::Return(ReturnVar::MutRefMirror(local_address, id));
          } else { res_message = Message::Return(ReturnVar::MutRefBorrow(res)); }
      }}
      response(stream, res_message);
    },
    None => { /* report unregistered function */ }}
},
\end{lstlisting}

\subsection{Extending Lifetime Management into the Distributed Setting}
\label{impl:lifetime}
Recall that in section \ref{impl:resource}, we briefly introduced storing and deallcating remoted owned resources on a node. In this section we discuss the design and implementation of a remote deallocation in detail. In a monolithic Rust program, when a variable that owns some resources reaches the end of its lifetime, in most cases, out of a program scope, the resources it owns get automatically deallocated. We extends this feature to the distributed setting. As illustrated in listing~\ref{impl:drop-eg}, when the proxy \texttt{a\_proxy} is initialised, some resources are allocated to the node with the address \texttt{addr}. Although these resources do not have an owner on the same node, they should not be deallocated until its remote owner \texttt{a\_proxy} reaches the end of its lifetime. 
\begin{lstlisting}[language=Rust, style=boxed, basicstyle=\footnotesize\ttfamily, caption={An example of a remote deallocation}, label=impl:drop-eg]
// on caller
fn main() {
  ...
  // the data of a_proxy is in the table on the receiver with addr
  // but it is owned by the caller and will be deallocated when its owner decides to drop it
  let a_proxy = remote!\bang!(addr, A::new(10)); 
  ...
  a_proxy.foo1(...)
} // a_proxy is out of scope, its data on the remote machine is dropped
\end{lstlisting}
For monolithic programs, the deallocation is achieved via the \texttt{drop} method in destructor trait \texttt{Drop}, which in most cases is automatically implemented for Rust types. We extend this \texttt{drop} method to handle deallocation of remotely owned resources. The implementation is shown in listing~\ref{impl:drop}.
When a proxy that owns some resources on a node reaches the end of its lifetime, a serialised deallocation message is automatically sent to the node that holds the resources. 
\begin{lstlisting}[language=Rust, style=boxed, basicstyle=\footnotesize\ttfamily, caption={The implementation of a remote deallocation}, label=impl:drop]
...
impl Drop for #name {
  fn drop(&mut self) {
    match self {
      Self::Remote(addr, id, is_owner) => {
        if is_owner.load(Ordering::Relaxed) {
          let msg = Message::Drop(*id);
          send(*addr, msg).unwrap(); }},
      _ => {}
}}}
...
\end{lstlisting}
As shown below, once a deallocation message is received by the targeted receiver, the entry with the corresponding \texttt{id} will be removed from the resource table.
\begin{lstlisting}[language=Rust, style=boxed, basicstyle=\footnotesize\ttfamily]
Message::Drop(id) => { mvtable.remove(&id); }
\end{lstlisting}\textbf{}

\section{The Operational Semantics}
\label{semantics}
We first provide a small-step operational semantics of a core language of Rust based on \citet{10.1145/3443420}'s FR, which captures the core features of Rust including copy- and move-semantics, owned and immutably/mutably borrowed references and lifetimes. We then present dFR, which extends FR to include distributed features of xRef such as remote copy- and move-semantics as well as remote references. We intend to show that such an extension preserves the semantics of FR, therefore the type safety claims of FR is preserved by dFR.

\subsection{The Revised Syntax and Semantics of FR}
\label{semantics:fr}
We present the revised syntax of FR in figure~\ref{syntax:r-syntax-fig}. Note that $\&w$ and $\&\texttt{mut }w$ represent immutable and mutable borrowing, $\mathscr{l}^\bullet$ and $\mathscr{l}^\circ$ are owned and borrowed references where $\mathscr{l}$ represents a location in a program state, and different from the original FR and Rust which do not have explicit syntax for move, we use $\#w$ to express move explicitly.

% Note that the $k$ in the block represents the lifetime.
\begin{figure}
\begin{alignat*}{3}
    \text{Term} \quad t \ \metaDeff \quad &\texttt{let mut } x = t;t &\text{declaration}\\
    \cmid \quad &w \metaDef t &\text{assignment}\\
    \cmid \quad &t;t &\text{sequence}\\
    \cmid \quad &\texttt{()} &\text{unit}\\
    \cmid \quad &\{t\} &\text{block}\\
    \cmid \quad &\texttt{box } t &\text{heap allocation}\\
    \cmid \quad &\&w \quad &\text{immutable borrow} \\
    \cmid \quad &\&\texttt{mut } w \quad &\text{mutable borrow} \\
    \cmid \quad &\#{w} \quad &\text{move} \\
    \cmid \quad &!{w} \quad &\text{copy} \\
    \cmid \quad &v \quad &\text{value} \\
    % \cmid \quad &w\\
    \text{LVal} \quad w \ \metaDeff \quad &x \quad &\text{variable} \\
    \cmid \quad &{*}w \quad &\text{dereference} \\
    \text{Value}(\mathcal{V}) \quad v \ \metaDeff \quad &\bot\\ 
    \cmid \quad &\texttt{()} \quad &\text{unit} \\
    \cmid \quad &i \quad &\text{integer} \\
    \cmid \quad &\mathscr{l}^\bullet &\text{owned reference} \\
    \cmid \quad &\mathscr{l}^\circ &\text{borrowed reference} \\
    \text{Location}\quad  \mathscr{l} \in \mathbb{A}
\end{alignat*}
\label{syntax:r-syntax-fig}
\caption{The revised syntax of FR}
\end{figure}

The notion of program state is introduced in figure \ref{semantics:program-state-fig}, which is a mapping from a location to a tuple of value and lifetime. When a value is replaced or its lifetime is expired, it will be removed from the program state.
\begin{figure}[b]
\begin{align*}
    &\mathcal{S}: \mathbb{A} \rightharpoonup \mathcal{V} \times \mathcal{L}\\
    &\mathcal{S} \mid \mathscr{l} \mapsto (v, m) \quad \text{where: } \mathscr{l} \in \textbf{dom}\;\mathcal{S} &\text{(update)}\\
    &\mathcal{S} \otimes \mathscr{l} \mapsto (v, m) \quad \text{where: } \mathscr{l} \notin \textbf{dom}\;\mathcal{S} &\text{(extend)}
\end{align*}
\label{semantics:program-state-fig}
\caption{The program state }
\end{figure}
We provide the operations of recursively removing values based on a location $\mathscr{l}$ and a lifetime $k$ from the state: 
\begin{align*}
      &\bigl(\mathcal{S}\otimes(\mathscr{l}^\bullet \mapsto (v, k))\bigr)\setminus {\mathscr{l}^\bullet} = \mathcal{S}\setminus v \\
      &\mathcal{S}\setminus v = \mathcal{S} \quad\text{(o/w)}
\end{align*}
and respectively:
\[
   \mathcal{S}\setminus k \ (\mathscr{l}) =
    \begin{cases}
      \mathcal{S}(\mathscr{l}) \quad\text{if $\mathcal{S}(\mathscr{l})=(v,k)$} \\
      \textbf{undefined}\quad\text{(o/w)}
    \end{cases}
\] % this  is not correct and I will revise it

Figure~\ref{semantics:r-reduction-fig} shows the small-step operational semantics of FR, which takes the form of a reduction $S, t \longrightarrow S', t'$, where $S$ is the program state before the evaluation of the term $t$ and $S', t'$ are the program state and term after the evaluation.
Evaluating a copy term simply makes a copy of a value $v$ at a given location $\mathscr{l}$, without modifying the program state, whereas evaluating a move term moves a value $v$ out of a given location $\mathscr{l}$.
A heap allocation $\texttt{box }v$ puts the value $v$ into a fresh location $\mathscr{l}$ and gives it the global lifetime $\top$, which contains all other lifetimes. The rule for evaluating a borrow term produces a borrowed reference of the give location $\mathscr{l}$.
Assignment places a given value $v'$ in the location $\mathscr{l}$, and recursively deallocates the old value $v$ from the program state.
The evaluation of a declaration allocates a given value $v$ to a fresh location $\mathscr{l}$ and substitutes latter occurrence of the declared variable $x$ with the owned reference $\mathscr{l}^\bullet$.

FR's lifetimes are based on the the lexical structure of programs. A block's lifetime $k$ based on the depth of the block. A block with deeper depth $\mathit{suc}\; k$ lives shorter than a block with depth $k$. The evaluation of a block is the evaluation of the term inside the block. At the end of the evaluation, a single value $v$ is obtained and values that have short lifetime than the current block are deallocated from the program state. The reduction rules for the evaluation of sequences are intuitive. We highlight the case for a sequence of which the first term is an owned reference. After evaluating the owned reference, it is recursively deallocated from the program state.
\begin{figure}
\begin{mathparpagebreakable}
    \inferrule*[right={(R-Copy)}]{\mathcal{S} (\mathscr{l}) = (v , m)}
    {\mathcal{S}, !{\mathscr{l}^\bullet} \longrightarrow \mathcal{S}, v}
    
    \inferrule*[right={(R-Move)}]{ }
    {\mathcal{S}\otimes \mathscr{l} \mapsto (v, m), \#\mathscr{l}^\bullet \longrightarrow \mathcal{S}\otimes \mathscr{l} \mapsto \bot, v}

    \inferrule*[right={(R-Box)}]{\mathscr{l} \notin \textbf{dom}\;\mathcal{S}}
    {\mathcal{S}, \texttt{box }v \longrightarrow \mathcal{S}\otimes \mathscr{l}\mapsto (v,\top), \mathscr{l}^\bullet}
    \vspace{-0.3cm}
    % \\\text{Heap locations are given global lifetime $\top$ which all other lifetimes are assumes to be inside.}

    \inferrule*[right={(R-Borrow)}]{\mathscr{l} \in \textbf{dom}\; \mathcal{S}}
    {\mathcal{S}, \&[\texttt{mut}]\mathscr{l}^\bullet \longrightarrow \mathcal{S}, \mathscr{l}^\circ}

    \inferrule*[right={(R-Assign (Owned))}]{ }
    {\mathcal{S}\otimes \mathscr{l} \mapsto (v, m), \mathscr{l}^\bullet \metaDef v' \longrightarrow (\mathcal{S}\setminus v)\otimes \mathscr{l} \mapsto (v', m), \texttt{()}}
    \vspace{-0.3cm}
    \\\text{Assignment should not change the lifetime of the original location}

    \inferrule*[right={(R-Assign (mut Borrowed))}]{ }
    {\mathcal{S}\otimes \mathscr{l} \mapsto (v, m), \mathscr{l}^\circ \metaDef v' \longrightarrow (\mathcal{S}\setminus v)\otimes \mathscr{l} \mapsto (v', m), \texttt{()}}

    \inferrule*[right={(R-Decl)}]{\mathscr{l} \notin \textbf{dom}\;\mathcal{S}}
    {\mathcal{S}, \texttt{let mut }x = v; t \stackrel k \longrightarrow \mathcal{S}\otimes \mathscr{l} \mapsto (v, k), t[x/\mathscr{l}^\bullet]}\\

    \inferrule*[right={(R-Block)}]{ }
    {\mathcal{S}, \{v\} \stackrel k\longrightarrow \mathcal{S}\setminus suc\ k, v}
    
    \inferrule*[right={(S-Block)}]
    {\mathcal{S}, t \stackrel {suc\ k}\longrightarrow \mathcal{S'}, t'}
    {\mathcal{S}, \{t\} \stackrel k\longrightarrow \mathcal{S'}, \{t'\}}
    
    \inferrule*[right={(R-Seq-OwnedRef)}]{\mathscr{l} \in \textbf{dom}\; \mathcal{S}}
    {\mathcal{S}, \mathscr{l}^\bullet; t \longrightarrow \mathcal{S}\setminus\mathscr{l}^\bullet, t} 
    
    \inferrule*[right={(R-Seq-BorrowedRef)}]{\mathscr{l} \in \textbf{dom}\; \mathcal{S}}
    {\mathcal{S}, \mathscr{l}^\circ; t \longrightarrow \mathcal{S}, t}

    \inferrule*[right={(R-Seq-Int)}]{ }
    {\mathcal{S}, i; t \longrightarrow \mathcal{S}, t}
    
    \inferrule*[right={(R-Seq-Unit)}]{ }
    {\mathcal{S}, \texttt{()}; t \longrightarrow \mathcal{S}, t}
\end{mathparpagebreakable}
    \caption{The semantics of revised FR}
    \label{semantics:r-reduction-fig}
\end{figure}
% \subsection{Evaluation Context}

An evaluation context is a term with a placeholder $\llbracket\cdot\rrbracket$. $E\llbracket t\rrbracket$ is a term obtained by replacing the placeholder with a term $t$. The evaluation context and reduction rule for the evaluation context are shown in figure~\ref{semantics:eval-context}.
\begin{figure}
    \begin{align*}
        E \metaDeff \llbracket \cdot \rrbracket \cmid E;t \cmid v; E \cmid \texttt{let mut }x=E; t \cmid \texttt{let mut }x = v; E \cmid \{E\} \cmid \texttt{box }E \cmid w = E
    \end{align*}
    \begin{mathpar}
    \inferrule*[right={(R-Context)}]{ S, t \longrightarrow S, t' }
        { S, E\llbracket t \rrbracket \longrightarrow  S', E\llbracket t' \rrbracket }
    \end{mathpar}
    \caption{Evaluation context}
    \label{semantics:eval-context}
\end{figure}

Next, we will discuss the semantics of dFR, which extends the FR with distributed computation features including remote references and values.
\subsection{The Syntax and Semantics of dFR} 
\label{semantics:dfr}
Figure~\ref{syntax:d-syntax-fig} shows the syntax of dFR, which is the syntax of FR extended with the remote declaration $\texttt{let mut}@n\; x = t;t$, remote heap allocation $\texttt{box } t$, remote values $v@n$ and remote terms $t@n$, where $n$ is the address of a node and $\mathcal{N}$ is the set of addresses. 
% $\mathscr{l}^\bullet_{@n}$ denotes a owned reference on the node $n$. 
\begin{figure}
\begin{alignat*}{3}
    \text{Term} \quad t \ \metaDeff \quad &\texttt{let mut } x = t;t &\text{declaration}\\
    \cmid \quad &\texttt{let mut}@n\; x = t;t &\text{remote declaration}\\
    \cmid \quad &w \metaDef t &\text{assignment}\\
    \cmid \quad &t;t &\text{sequence}\\
    \cmid \quad &\texttt{()} &\text{unit}\\
    \cmid \quad &\{t\} &\text{block}\\
    \cmid \quad &\texttt{box } t &\text{heap allocation}\\
    \cmid \quad &\texttt{box}@n\; t &\text{remote  heap allocation}\\
    \cmid \quad &\&w \quad &\text{immutable borrow} \\
    \cmid \quad &\&\texttt{mut } w \quad &\text{mutable borrow} \\
    \cmid \quad &\#{w} \quad &\text{move} \\
    \cmid \quad &!{w} \quad &\text{copy} \\
    \cmid \quad &v \quad &\text{value} \\
    \cmid \quad &v@n \quad &\text{remote value}\\
    % \cmid \quad &w\\
    \text{Remote Term} \quad t_d \metaDeff \quad &t@n\\
    \text{LVal} \quad w \ \metaDeff \quad &x \quad &\text{variable} \\
    \cmid \quad &{*}w \quad &\text{dereference} \\
    \text{Value}(\mathcal{V}) \quad v \ \metaDeff \quad &\bot\\ 
    \cmid \quad &\texttt{()} \quad &\text{unit} \\
    \cmid \quad &i \quad &\text{integer} \\
    \cmid \quad &\mathscr{l}^\bullet &\text{owned reference} \\
    \cmid \quad &\mathscr{l}^\circ &\text{borrowed reference} \\
    % \cmid \quad &(n, v) &\text{remote value}\\
    \text{Location}\quad  \mathscr{l} \in \mathbb{A}\\
    \text{Node}\quad n \in \mathcal{N}
\end{alignat*}
\label{syntax:d-syntax-fig}
\caption{The syntax of dFR}
\end{figure}

Building upon the program state $\mathcal{S}$ for FR, in figure~\ref{d-state}, we introduce the distributed program state $\mathcal{D}$, which maps addresses of nodes to their program states. The reduction rule takes the form of $\mathcal{D}, \mathcal{C}_s \longrightarrow \mathcal{D'}, \mathcal{C}_s'$, where $\mathcal{C}_s$ and $\mathcal{C}_s'$ are configuration stacks. For each reduction, the term on the top of a configuration stack $\mathcal{C}_s$ gets evaluated. The element of the configuration stack can either be a pair of an address and a hole ($n, ?$) or a pair of an address and a term ($n, t$).
\begin{figure}
    \begin{align*}
        &\mathcal{D}: \mathcal{N} \rightharpoonup \mathcal{S}
        %&\mathit{nt} \in  \mathcal{N} \times\mathds{1} + \mathcal{N}\times T\\
        &\mathit{nt} \in  \mathcal{N} \times\mathds{1} + \mathcal{N}\times T\\
        &\mathcal{C}_s : (nt)^*
        &\mathrm{Configuration}: \mathcal{D}, \mathcal{C}_s
    \end{align*}
    \label{d-state}
    \caption{Distributed program state and configuration stack}
\end{figure}

Utilising the concepts of distributed program state and configuration stack, we provide the semantics of dFR in figure~\ref{semantics:eval-distributed}. Firstly, all reductions rules for evaluating terms in FR can be adapted into reduction rules for dFR via the rule Local Term. To evaluate copying a remotely owned reference $\mathscr{l}^\bullet_{@n'}$ on a node with address $n$, the first step is to update the configuration stack by changing the $(n, !\mathscr{l}^\bullet_{@n'})$ to $(n, ?)$, and pushing a new address-term pair $(n', !\mathscr{l}^\bullet)$ to be evaluated onto the stack. And then the copy term $!\mathscr{l}^\bullet$ gets evaluated on the node $n'$, and the resulting value annotated with the address $n'$ is passed back to fill in the hole. Similarly, as for the semantics of moving the value out of a remote owned reference, the first step is to replace the term on the node $n$ with a hole, and pass the copy term to the node $n'$ to evaluate. The resulting value $v$ annotated with the address $n'$ is passed back to the node $n$ at the end of the evaluation to fill in the hole, and the value of the location $\mathscr{l}$ at the program state of the node $n'$ is replaced by $\bot$.

To evaluate a remote heap allocation $\texttt{box}@n'\; v$ on the node $n$, firstly, the heap allocation is passed to the node $n'$, and $v$ is stored in a fresh location $\mathscr{l}$ at the program state of the node $n'$. The owned reference is then passed back to the node $n$ allowing the node $n$ to own the location $\mathscr{l}$ created by the heap allocation on the node $n'$. On a given node $n$, to borrow a remotely owned reference from a different node $n'$, a remotely borrowed reference $\mathscr{l}^\circ_{@n'}$ is passed back to the node $n$ at the end of the evaluation.

A remote assignment $\mathscr{l}^\bullet_{@n'} \metaDef v'$ on the node $n$ assigns a new value $v'$ to its remotely owned reference on the node $n'$. It modifies the program state on the node $n'$ by recursively deallocates the old value $v$ which is stored in the location $\mathscr{l}$ and assigns the location $\mathscr{l}$ with the new value $v'$. The evaluation of a remote declaration is more complicated. The first step leaves a hole for the substitution of the declared variable $x$. Once a fresh location $\mathscr{l}$ on the node $n'$ is allocated with the value $v$, the owned reference $\mathscr{l}^\bullet$ will then be passed back to the node $n$ and all occurrences of the declared variable will be substituted with the remote owned reference $\mathscr{l}_{@n'}^\bullet$.

\begin{figure}
    \begin{mathparpagebreakable}
        \inferrule*[right={(Copy (s1))}]{ \mathcal{D}(n')(\mathscr{l}) = (v, m) }
        {\mathcal{D}, \mathcal{C}_s \concat (n, !\mathscr{l}^\bullet_{@n'}) \longrightarrow \mathcal{D}, \mathcal{C}_s \concat (n, ?) \concat (n', !\mathscr{l}^\bullet)}
        
        \inferrule*[right={(Copy (s2))}]{ \mathcal{D}(n')(\mathscr{l}) = (v, m)}
        {\mathcal{D}, \mathcal{C}_s \concat (n, ?) \concat (n',!\mathscr{l}^\bullet) \longrightarrow \mathcal{D}, \mathcal{C}_s \concat (n, v@n')}

        \inferrule*[right={(Move (s1))}]{ }
        {\mathcal{D} \otimes (n' \mapsto \mathcal{S}\otimes\mathscr{l} \mapsto (v, m)), \mathcal{C}_s \concat (n, \#\mathscr{l}^\bullet_{@n'}) \longrightarrow \\\mathcal{D} \otimes (n' \mapsto \mathcal{S}\otimes\mathscr{l} \mapsto (v, m)), \mathcal{C}_s \concat (n, ?) \concat (n', \#\mathscr{l}^\bullet)}

        \inferrule*[right={(Move (s2))}]{ }
        {\mathcal{D} \otimes (n' \mapsto \mathcal{S}\otimes \mathscr{l} \mapsto (v, m)), \mathcal{C}_s \concat (n, ?) \concat (n', \#\mathscr{l}^\bullet) \longrightarrow \\\mathcal{D} \otimes (n' \mapsto \mathcal{S}\otimes\mathscr{l} \mapsto \bot), \mathcal{C}_s \concat (n, v@n')}

        \inferrule*[right={(Box (s1))}]{ }
        {\mathcal{D}, \mathcal{C}_s \concat (n, (\texttt{box} @ n' v)) \longrightarrow \mathcal{D}, \mathcal{C}_s \concat (n, ?) \concat (n', \texttt{box } v)}

        \inferrule*[right={(Box (s2))}]{ \mathscr{l} \notin \textbf{dom}\;\mathcal{D}(n') }
        {\mathcal{D}, \mathcal{C}_s \concat (n, ?) \concat (n', \texttt{box } v) \longrightarrow \mathcal{D} \mid (n' \mapsto \mathcal{D}(n')\otimes\mathscr{l}\mapsto (v, \top)), \mathcal{C}_s \concat (n, \mathscr{l}^\bullet_{@n'})} 

        \inferrule*[right={(Borrow (s1))}]{ \mathscr{l} \in \textbf{dom}\;\mathcal{D}(n') }
        {\mathcal{D}, \mathcal{C}_s \concat (n, \&[\texttt{mut}]\mathscr{l}^\bullet_{@n'}) \longrightarrow \mathcal{D}, \mathcal{C}_s \concat (n, ?) \concat (n', \&[\texttt{mut}]\mathscr{l}^\bullet)}

        \inferrule*[right={(Borrow (s2))}]{ \mathscr{l} \in \textbf{dom}\;\mathcal{D}(n') }
        {\mathcal{D}, \mathcal{C}_s \concat (n, \&[\texttt{mut}]\mathscr{l}^\bullet_{@n'}) \longrightarrow \mathcal{D}, \mathcal{C}_s \concat (n, \mathscr{l}^\circ_{@n'})}

        \inferrule*[right={(Assign (s1))}]{ }
        {\mathcal{D} \otimes (n' \mapsto \mathcal{S}\otimes \mathscr{l} \mapsto (v, m)), \mathcal{C}_s \concat (n, \mathscr{l}_{@n'}^\bullet \metaDef v') \longrightarrow \\ \mathcal{D}\otimes (n' \mapsto \mathcal{S}\otimes \mathscr{l} \mapsto (v, m)), \mathcal{C}_s \concat (n, ?) \concat (n', \mathscr{l}^\bullet \metaDef v')}

        \inferrule*[right={(Assign (s2))}]{ }
        {\mathcal{D}\otimes (n' \mapsto \mathcal{S}\otimes \mathscr{l} \mapsto (v, m)), \mathcal{C}_s \concat (n, ?) \concat (n', \mathscr{l}^\bullet \metaDef v') \longrightarrow \\ \mathcal{D}\otimes (n' \mapsto \mathcal{S} \setminus v \otimes \mathscr{l} \mapsto (v', m)), \mathcal{C}_s \concat (n, \texttt{()})}

        \inferrule*[right={(Decl (s1))}]{ }
        {\mathcal{D}, \mathcal{C}_s \concat (n, \texttt{let mut}@n'\; x = v; t) \longrightarrow\\ \mathcal{D}, \mathcal{C}_s \concat (n, t[x/?]) \concat (n', \texttt{let mut } x = v; x)}

        \inferrule*[right={(Decl (s2))}]{ \mathscr{l} \notin \textbf{dom}\;\mathcal{D}(n') }
        {\mathcal{D}, \mathcal{C}_s \concat (n, t[x/?]) \concat (n', \texttt{let mut } x = v; x) \longrightarrow \\\mathcal{D} \otimes (n' \mapsto \mathcal{S}\otimes \mathscr{l} \mapsto (v, k)), \mathcal{C}_s \concat (n, t[x/ \mathscr{l}^\bullet_{@n'}])}

        \inferrule*[right={(Local Terms)}]{ \mathcal{S}, t \longrightarrow \mathcal{S}', t'}
        {\mathcal{D}\otimes(n \mapsto \mathcal{S}), \mathcal{C}_s \concat (n, t) \longrightarrow \mathcal{D}\otimes(n \mapsto \mathcal{S}'), \mathcal{C}_s \concat (n, t')}

        \inferrule*[right={(Remote Terms)}]{\mathcal{D}\otimes(n \mapsto \mathcal{S}), \mathcal{C}_s \concat (n, t) \longrightarrow \mathcal{D}\otimes(n \mapsto \mathcal{S}'), \mathcal{C}_s \concat (n, t')}
        {\mathcal{D}\otimes(n' \mapsto \mathcal{S}), \mathcal{C}_s \concat (n, t@n') \longrightarrow \mathcal{D}\otimes(n' \mapsto \mathcal{S}'), \mathcal{C}_s \concat (n, t@n')}
    \end{mathparpagebreakable}
    \caption{The semantics of dFR}
    \label{semantics:eval-distributed}
\end{figure}

\subsection{Type Safety of the Extension}
By extending FR into dFR, the type system and static checking of the validity of owning, immutably borrowing and mutably borrowing resources remain unchanged. This is because with our design, if we flatten a distributed program in a single node program, the flattened result of the execution of the distributed program should be the same as the result of the execution of the flattened single node program. Formally, we state this property of our distributed extension in theorem~\ref{thm:loc-transp}.

Note that the reverse direction of the theorem does not hold. Since to extend a given single node program into a distributed program by allocating the program state on arbitrary nodes and making the term involved in the execution containing remote components that live on arbitrary nodes may not lead to constructing a distributed program that can be successfully executed. However, because our goal is to show that the distributed program preserves the same behaviour as if it is a single node program, having only one direction in the theorem is sufficient.

\begin{theorem}[Location Transparency]
For any term $t$, given an initial distributed program state $\mathcal{D}$ and an initial single node program state $\mathcal{S}$, where the flattened distributed program state equals to the single node program state, if a distributed execution of a term $t$ that may be a remote term or contain remote component with the distributed program state $\mathcal{D}$ results in a distributed program state $\mathcal{D}'$ and a value $v$ which can be either remote or local, then the execution of the flattened term $t$ with the single node program state $\mathcal{S}$ will gives a state $\mathcal{S}'$ and value $v'$, where the flattened resulting distributed program state $|\mathcal{D}'|$ equals to the $S'$ and the flattened value $v$ equals to $v'$. Note that we make locations on all nodes distinct to simplify the proof.
\begin{align*}
    % &\forall t \in \Pi_{\mathit{ref}}.\; \phi_\mathcal{D}, [t] \longrightarrow \mathcal{D}, [v] \iff \phi_\mathcal{S},  t|_@ \longrightarrow \mathcal{S}, v' \land \mathcal{S} = |\mathcal{D}| \land v' = v\\
    &\forall t \in \mathrm{Term}.\; \mathcal{D}, [(n, t)] \longrightarrow \mathcal{D'}, [(n, v)] \land |\mathcal{D}| = \mathcal{S}  \Rightarrow \mathcal{S},  t|_@ \longrightarrow \mathcal{S'}, v' \land |\mathcal{D}'| = \mathcal{S}' \land v|_@ = v'\\
    &\mathrm{where:}\\
    &|\mathcal{D}| = \bigcup_{\forall n \in \textbf{dom} \mathcal{D}} \mathcal{D}(n)\\
    &\texttt{let mut }@n\; x=t; t|_@ =  \texttt{let mut } x=t; t\\
    &\texttt{box}@n\; t |_@ = \texttt{box }t\\
    &v@n|_@ = v\\
    &t_d|_@ = t |_@
\end{align*}
\label{thm:loc-transp}
\end{theorem}
Since a term $t$ is always a closed term, we prove the theorem~\ref{thm:loc-transp} by structural induction on the term $t$.
\begin{proof}[Case copy]
    \begin{align*}
    &\text{We assume:}\\
    &\mathcal{D} = \mathcal{D}_0 \otimes (n' \mapsto (l\mapsto (v, m)))\quad
    \mathcal{S} = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m))\\
    &|\mathcal{D}| = \mathcal{S}\\
    &\text{The distributed execution gives:}\\
    &\mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto (v,m))) , [(n, !\mathscr{l}^\bullet_{@n'})] \longrightarrow \mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto (v, m))), [(n, v@n')]\\
    &\text{The monolithic execution gives:}\\
    &\mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m)), !\mathscr{l}^\bullet_{@n'}|_@ \longrightarrow \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m)), v\\
    &\text{To conclude, after executions:}\\
    &\mathcal{D}' = \mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto (v, m))) \quad 
    \mathcal{S}' = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m))\\
    &|\mathcal{D}'| = \mathcal{S}' \quad \text{and} \quad v@n'|_@ = v
    \end{align*}
\end{proof}
\begin{proof}[Case move]
    \begin{align*}
    &\text{We assume:}\\
    &\mathcal{D} = \mathcal{D}_0 \otimes (n' \mapsto (l\mapsto (v, m)))\quad
    \mathcal{S} = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m))\\
    &|\mathcal{D}| = \mathcal{S}\\
    &\text{The distributed execution gives:}\\
    &\mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto (v,m))) , [(n, \#\mathscr{l}^\bullet_{@n'})] \longrightarrow \mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto \bot), [(n, v@n')]\\
    &\text{The monolithic execution gives:}\\
    &\mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m)), \#\mathscr{l}^\bullet_{@n'}|_@ \longrightarrow \mathcal{S}_0 \otimes (\mathscr{l} \mapsto \bot), v\\
    &\text{To conclude, after executions:}\\
    &\mathcal{D}' = \mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto \bot)) \quad 
    \mathcal{S}' = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto \bot)\\
    &|\mathcal{D}'| = |\mathcal{D}_0| \otimes (\mathscr{l} \mapsto \bot) = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto \bot) = \mathcal{S}' \quad \text{and} \quad v@n'|_@ = v
    \end{align*}
\end{proof}
\begin{proof}[Case box]
    \begin{align*}
    &\text{We assume:}\\
    &|\mathcal{D}| = \mathcal{S} \quad \mathscr{l} \notin \textbf{dom}\; \mathcal{D}(n') \quad \mathscr{l} \notin \textbf{dom}\; \mathcal{S}\\
    &\text{The execution of the distributed program gives:}\\
    &\mathcal{D}, [(n, \texttt{box}@n'\;v)] \longrightarrow \mathcal{D} \mid (n' \mapsto \mathcal{D}(n')\otimes(\mathscr{l} \mapsto (v, \top))), [(n, \mathscr{l}^\bullet_{@n'})]\\
    &\text{The execution of the monolithic program gives:}\\
    &\mathcal{S}, (\texttt{box}@n'\;v)|_@ \longrightarrow \mathcal{S} \otimes (\mathscr{l} \mapsto (v, \top)), \mathscr{l}^\bullet\\
    &\text{To conclude, after executions:}\\
    &\mathcal{D}' = \mathcal{D}(n')\otimes(\mathscr{l} \mapsto (v, \top)) \quad 
    \mathcal{S}' =  \mathcal{S} \otimes (\mathscr{l} \mapsto (v, \top))\\
    &|\mathcal{D}'| = |\mathcal{D}| \otimes (\mathscr{l} \mapsto (v, \top)) = \mathcal{S} \otimes (\mathscr{l} \mapsto (v, \top))= \mathcal{S}' \quad \text{and} \quad \mathscr{l}^\bullet_{@n'}|_@ = \mathscr{l}^\bullet
    \end{align*}
\end{proof}
\begin{proof}[Case borrow]
    \begin{align*}
    &\text{We assume:}\\
    &|\mathcal{D}| = \mathcal{S} \quad \mathscr{l} \in \textbf{dom}\; \mathcal{D}(n') \quad \mathscr{l} \in \textbf{dom}\; \mathcal{S}\\
    &\text{The execution of the distributed program gives:}\\
    &\mathcal{D}, [(n, \&[\texttt{mut}]\mathscr{l}^\bullet_{@n'})] \longrightarrow \mathcal{D} [(n, \mathscr{l}^\circ_{@n'})]\\
    &\text{The execution of the monolithic program gives:}\\
    &\mathcal{S}, (\&[\texttt{mut}]\mathscr{l}^\bullet_{@n'})|_@ \longrightarrow \mathcal{S}, \mathscr{l}^\circ\\
    &\text{To conclude, after executions:}\\
    &\mathcal{D}' = \mathcal{D}\quad 
    \mathcal{S}' =  \mathcal{S}\quad
    |\mathcal{D}'| = \mathcal{S}' \quad \text{and} \quad \mathscr{l}^\circ_{@n'}|_@ = \mathscr{l}^\circ
    \end{align*}
\end{proof}
\begin{proof}[Case assign]
    \begin{align*}
    &\text{We assume:}\\
    &\mathcal{D} = \mathcal{D}_0 \otimes (n' \mapsto (l\mapsto (v, m)))\quad
    \mathcal{S} = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m))\\
    &|\mathcal{D}| = \mathcal{S}\\
    &\text{The execution of the distributed program gives:}\\
    &\mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto (v,m))) , [(n, \mathscr{l}^\bullet_{@n'} \metaDef v')] \longrightarrow \mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto (v',m))), [(n, \texttt{()}@n')]\\
    &\text{The execution of the monolithic program gives:}\\
    &\mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v, m)), (\mathscr{l}^\bullet_{@n'} \metaDef v')|_@ \longrightarrow \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v', m)), \texttt{()}\\
    &\text{To conclude, after executions:}\\
    &\mathcal{D}' = \mathcal{D}_0 \otimes (n' \mapsto (\mathscr{l} \mapsto (v',m))) \quad 
    \mathcal{S}' = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v', m))\\
    &|\mathcal{D}'| = |\mathcal{D}_0| \otimes (\mathscr{l} \mapsto (v', m)) = \mathcal{S}_0 \otimes (\mathscr{l} \mapsto (v', m)) = \mathcal{S}' \quad \text{and} \quad \texttt{()}@n'|_@ = \texttt{()}
    \end{align*}
\end{proof}
\begin{proof}[Case decl]
    \begin{align*}
    &\text{We assume:}\\
    &|\mathcal{D}| = \mathcal{S} \quad \mathscr{l} \notin \textbf{dom}\; \mathcal{D}(n') \quad \mathscr{l} \notin \textbf{dom}\; \mathcal{S}\\
    &\text{The execution of the distributed program gives:}\\
    &\mathcal{D}, [(n, \texttt{let mut}@n' x = v;t)] \longrightarrow \mathcal{D} \mid (n' \mapsto \mathcal{D}(n')\otimes(\mathscr{l} \mapsto (v, k))), [(n, t[x/\mathscr{l}^\bullet_{@n'}])]\\
    &\text{The execution of the monolithic program gives:}\\
    &\mathcal{S}, (\texttt{let mut}@n' x = v;t)|_@ \longrightarrow \mathcal{S} \otimes (\mathscr{l} \mapsto (v, k)), t[x/\mathscr{l}^\bullet]\\
    &\text{To conclude, after executions:}\\
    &\mathcal{D}' = \mathcal{D} \mid (n' \mapsto \mathcal{D}(n')\otimes(\mathscr{l} \mapsto (v, k))) \quad 
    \mathcal{S}' = \mathcal{S} \otimes (\mathscr{l} \mapsto (v, k))\\
    &|\mathcal{D}'| = |\mathcal{D}| \otimes (\mathscr{l} \mapsto (v, k)) = \mathcal{S} \otimes (\mathscr{l} \mapsto (v, k)) = \mathcal{S}' \quad \text{and} \quad t[x/\mathscr{l}^\bullet]|_@ = t[x/(\mathscr{l}^\bullet)|_@] = t[x/\mathscr{l}^\bullet]
    \end{align*}
\end{proof}
The proofs for location transparency of the distributed and monolithic executions of local terms and remote terms should then be trivial.

\section{Related Works}
\label{chap3:related-works}

\section{Conclusion}
\label{chap3:conclusion}

\section{Epilogue}
\label{chap3:epilogue}