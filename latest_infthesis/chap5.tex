\Chapter{The~Thorn~and~The~Bird:~Still~We~Do~It}{Conclusion}
\label{chap5}
\begin{tikzpicture}[color=black,
                   transform shape,
                   every node/.style={inner sep=0pt}]
\node[minimum width=\framesize, minimum height=0.45 *\framesize, fill=white](vecbox){};
\node[anchor=north west] at (vecbox.north west){% 
\pgfornament[width=0.1*\framesize]{61}};
\node[anchor=north east] at (vecbox.north east){% 
\pgfornament[width=0.1*\framesize,symmetry=v]{61}};
\node[anchor=south west] at (vecbox.south west){% 
\pgfornament[width=0.1*\framesize,symmetry=h]{61}};
\node[anchor=south east] at (vecbox.south east){% 
\pgfornament[width=0.1*\framesize,symmetry=c]{61}};
\node[anchor=north] at (vecbox.north){% 
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
};

\node[anchor=south] at (vecbox.south){% 
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
};
\node[text width=0.85\framesize, align=justify] at (vecbox.center){%
The bird with the thorn in its breast, it follows an immutable law; it is driven by it knows not what to impale itself, and die singing. At the very instant the thorn enters there is no awareness in it of the dying to come; it simply sings and sings until there is not the life left to utter another note. But we, when we put the thorns in our breasts, we know. We understand. And still we do it. Still we do it.\\ 
\rightline{--- Colleen McCullough ``The Thorn Birds"}};
\end{tikzpicture}
% I might think about a better title
% I think this title is good enough
\lettrine{T}{hroughout} this manuscript, three conceptual questions have been addressed via three studies presented in chapter~\ref{chap2}, chapter~\ref{chap3}, and chapter~\ref{chap4}, ultimately, they all relate to the fundamental motivation of my researches concerning the meaning of computer programs --- to design better abstraction for modelling and understanding programs as well as better formal frameworks for reasoning about programs.

The study discussed in chapter~\ref{chap2} is conducted to address the first conceptual question: How to design a better abstraction mechanism that allows programmers to effectively express \emph{what} they want a computer to do via some declarative yet accurate \emph{specifications} instead of \emph{how} a computer should accomplish a task via some concrete \emph{implementations}? The study specifically focuses on designing property-based container types in programming languages. In particular, we investigate ways to declaratively specify the properties of container types using formal specifications instead of having these properties concretely implemented for container types, allowing concrete implementations to be inferred from the specifications. In this study, we utilise existing verification techniques including formal specifications, data refinement, and refinement types for the purpose of designing declarative yet accurate abstractions. We demonstrate that these specifications describing \emph{what} properties, especially properties giving an account of functional requirements that a container type and its operations should satisfy, which are separated from concrete container implementations describing \emph{how} properties are satisfied. In terms of addressing the conceptual question regarding to the understanding of the relationship between specifications and implementations, the design of property based container types in this study indicates that declarative specifications enable better automation and optimisation for application programmers when selecting desired container implementations in programs. 

The study discussed in chapter~\ref{chap3} is conducted to address the second conceptual question: How to intuitively understand \emph{distributed programs} using the same conceptual model as \emph{monolithic programs}? The study focuses on designing, implementing, and formalising a UMI framework as a Rust library. This UMI framework allows a distributed program to be migrated a monolithic program without massive changes to the syntax or structure of the original monolithic program. In addition, the semantics of the monolithic program is preserved. By formalising the core calculus of the UMI framework implemented as a distributed extension of Rust, we argue that our UMI framework extends Rust's memory safety guarantees into a distributed setting by utilising Rust's ownership and lifetime system in distributed memory management. In terms of addressing the conceptual question regarding to understanding the connection between monolithic programs and distributed programs, the UMI framework demonstrates that a monolithic program can be viewed as an abstraction of a distributed program. Rather than requiring programmers to implement \emph{how} some functionalities are achieved in a distributed setting via network communication protocols and message passing, programmers only need to specify \emph{what} these functionalities a distributed program is required to achieve in terms of a monolithic program by abstracting away the details of distributed memory management and message passing over a network.

The study discussed in chapter~\ref{chap4} is conducted to address the third conceptual question: How do we characterise the relationship between the \emph{syntax} and \emph{semantics} of programming languages? The study focuses on a thorough examination of the semantics of a core calculus --- System S --- of a family of strategic rewriting languages that instructs syntactic transformations. More specifically, we formalise a denotational semantics and big-step operational semantics of System S, featuring errors, divergence, and non-determinism. In addition, we prove the equivalence of these two semantic models, showing that they are equally expressive, and model the same meaning of System S. We then present an axiomatic model of System S, which is a weakest precondition calculus, allowing us to reason about the executions of rewrites encoded in System S. Regarding to the conceptual question, this study demonstrate a perhaps interesting observation: As for strategic rewriting languages, the syntax and semantics are interdependent. The syntactic transformations of expressions encode the meaning for the evaluation of these expressions, and by designing and analysing three different formal models of semantics, we are able to characterise and reason about the executions of compositions of these syntactic transformations.

% With respect to the theme of this manuscript --- studies concerning the meaning of computer programs, 
There is one important observation shared by all three studies: There is always a trade-off between the expressiveness and the elegance of abstraction when modelling programming languages. In the first study, we have observed that it is challenging to express performance related non-functional properties for containers using the declarative formal specification we have designed. In the second project, we have presented our UMI framework which provides a conceptual modelling which views a monolithic program as a functional specification of a distributed program, abstracting over the complicated network communication details while extending the memory safety guarantees provided by the monolithic program into a the distributed program. However, such an abstraction is not expressive enough to capture the failures caused by the network communication problems and server errors. In the third project, in order to formalise concise and elegant semantics of the composition of syntactic transformations, we abstract away the detail implementations of the atomic strategies and model them as partial functions. However, such an abstraction is not expressive enough to model concepts such as side effects of the execution of atomic strategies. To summarise such an observation, ff the model is too detailed and precise, it may become overly specific and complicated, lose the generality, and obscure the high-level structure of the language features that it models. However, if the model if too abstract, it may lose the some important aspects of the language features that it models. When we are designing a formal model to demonstrate some principled understanding of some features we care in a programming language, we should always take the balancing between expressiveness and abstraction into consideration. 

Back to the theme of this manuscript --- studies concerning the meaning of computer programs, we have conducted three studies relating to explore better techniques for modelling some important features and components of programming languages, including container types, distributed programming, and term rewriting. These studies enable programmers to gain principled understanding of computer programs, to effectively communicate desired functionalities to computers without being overly specific, and to reason about the executions of programs. 

\begin{center}
\vspace{-0.7em}
\pgfornament[width=0.08*\framesize]{11}
\pgfornament[width=0.08*\framesize]{80}
\pgfornament[width=0.08*\framesize]{14}
\vspace{-0.3em}
\end{center}

Everything beautiful will eventually come to an end. Although I have been asking different questions, wondering around different paths, and searching for different angles to gain some understandings of the questions I have been asking, like the bird with the impaling thorn, everything I have been exploring eventually leads to the same direction: I am in the process of searching for the meaning of the world, especially the world of which I am the centre --- and in the end the result might just be: \emph{It is meaningless}. Nevertheless, I know, I understand, even if there is nothing there, still I search for it, till the end of my life, still I search for it.


% - FIN -

% Till the end of this journey, instead of proudly announcing that I have provided an answer stating how significant the works have been done which contribute to designing better programming languages and having better reasoning frameworks for programming languages, I find myself still in the process of modelling, assigning, questioning and understanding the \emph{meaning} of computer programs. It has already become a small yet important part of my journey of searching for the meaning of the world, especially the world of which I am the centre --- and in the end the result might just be \emph{it is meaningless}. However, I understand, even if there is nothing there, still I search for it, till the end of my life, still I search for it.