\Chapter{The~Thorn~and~The~Bird:~Still~We~Do~It}{Conclusion}
\label{chap5}
\begin{tikzpicture}[color=black,
                   transform shape,
                   every node/.style={inner sep=0pt}]
\node[minimum width=\framesize, minimum height=0.45 *\framesize, fill=white](vecbox){};
\node[anchor=north west] at (vecbox.north west){% 
\pgfornament[width=0.1*\framesize]{61}};
\node[anchor=north east] at (vecbox.north east){% 
\pgfornament[width=0.1*\framesize,symmetry=v]{61}};
\node[anchor=south west] at (vecbox.south west){% 
\pgfornament[width=0.1*\framesize,symmetry=h]{61}};
\node[anchor=south east] at (vecbox.south east){% 
\pgfornament[width=0.1*\framesize,symmetry=c]{61}};
\node[anchor=north] at (vecbox.north){% 
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
};

\node[anchor=south] at (vecbox.south){% 
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
};
\node[text width=0.85\framesize, align=justify] at (vecbox.center){%
The bird with the thorn in its breast, it follows an immutable law; it is driven by it knows not what to impale itself, and die singing. At the very instant the thorn enters there is no awareness in it of the dying to come; it simply sings and sings until there is not the life left to utter another note. But we, when we put the thorns in our breasts, we know. We understand. And still we do it. Still we do it.\\ 
\rightline{--- Colleen McCullough ``The Thorn Birds"}};
\end{tikzpicture}
% I might think about a better title
% I think this title is good enough
\lettrine{T}{hroughout} this manuscript, three conceptual questions have been addressed via three studies presented in chapter~\ref{chap2}, chapter~\ref{chap3}, and chapter~\ref{chap4}, ultimately, they all relate to the fundamental motivation of my researches concerning the meaning of computer programs --- to design better abstraction for modelling and understanding programs as well as better formal frameworks for reasoning about programs.

The study discussed in chapter~\ref{chap2} is conducted to address the first conceptual question: How to design a better abstraction mechanism that allows programmers to effectively express \emph{what} they want a computer to do via some declarative yet accurate \emph{specifications} instead of \emph{how} a computer should accomplish a task via some concrete \emph{implementations}? The study specifically focuses on designing property-based container types in programming languages. In particular, we investigate ways to declaratively specify the properties of container types using formal specifications instead of having these properties concretely implemented for container types, allowing concrete implementations to be inferred from the specifications. In this study, we utilise existing verification techniques including formal specifications, data refinement, and refinement types for the purpose of designing declarative yet accurate abstractions. We demonstrate that these specifications describing \emph{what} properties, especially properties giving an account of functional requirements that a container type and its operations should satisfy, which are separated from concrete container implementations describing \emph{how} properties are satisfied. In terms of addressing the conceptual question regarding to the understanding of the relationship between specifications and implementations, the design of property based container types in this study indicates that declarative specifications enable better automation and optimisation for application programmers when selecting desired container implementations in programs. 

The study discussed in chapter~\ref{chap3} is conducted to address the second conceptual question: How to intuitively understand \emph{distributed programs} using the same conceptual model as \emph{monolithic programs}? The study focuses on designing, implementing, and formalising a UMI framework as a Rust library. This UMI framework allows a distributed program to be migrated a monolithic program without massive changes to the syntax or structure of the original monolithic program. In addition, the semantics of the monolithic program is preserved. By formalising the core calculus of the UMI framework implemented as a distributed extension of Rust, we argue that our UMI framework extends Rust's memory safety guarantees into a distributed setting by utilising Rust's ownership and lifetime system in distributed memory management. In terms of addressing the conceptual question regarding to understanding the connection between monolithic programs and distributed programs, the UMI framework demonstrates that a monolithic program can be viewed as an abstraction of a distributed program. Rather than requiring programmers to implement \emph{how} some functionalities are achieved in a distributed setting via network communication protocols and message passing, programmers only need to specify \emph{what} these functionalities a distributed program is required to achieve in terms of a monolithic program by abstracting away the details of distributed memory management and message passing over a network.

The study discussed in chapter~\ref{chap4} is conducted to address the third conceptual question: How do we characterise the relationship between the \emph{syntax} and \emph{semantics} of programming languages? The study focuses on a thorough examination of the semantics of a core calculus --- System S --- of a family of strategic rewriting languages that instructs syntactic transformations. More specifically, we formalise a denotational semantics and big-step operational semantics of System S, featuring errors, divergence, and non-determinism. In addition, we prove the equivalence of these two semantic models, showing that they are equally expressive, and model the same meaning of System S. We then present an axiomatic model of System S, which is a weakest precondition calculus, allowing us to reason about the executions of rewrites encoded in System S.

\begin{center}
\vspace{-0.7em}
\pgfornament[width=0.08*\framesize]{11}
\pgfornament[width=0.08*\framesize]{80}
\pgfornament[width=0.08*\framesize]{14}
\vspace{-0.3em}
\end{center}

Everything beautiful will eventually come to an end. Although I have been asking different questions, wondering around different paths, and searching for different angles to gain some understandings of the questions I have been asking, like the bird with the impaling thorn, everything I have been exploring eventually leads to the same direction: I am in the process of searching for the meaning of the world, especially the world of which I am the centre --- and in the end the result might just be: \emph{It is meaningless}. Nevertheless, I know, I understand, even if there is nothing there, still I search for it, till the end of my life, still I search for it.


% - FIN -

% Till the end of this journey, instead of proudly announcing that I have provided an answer stating how significant the works have been done which contribute to designing better programming languages and having better reasoning frameworks for programming languages, I find myself still in the process of modelling, assigning, questioning and understanding the \emph{meaning} of computer programs. It has already become a small yet important part of my journey of searching for the meaning of the world, especially the world of which I am the centre --- and in the end the result might just be \emph{it is meaningless}. However, I understand, even if there is nothing there, still I search for it, till the end of my life, still I search for it.