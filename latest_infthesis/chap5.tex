\Chapter{The~Thorn~and~The~Bird:~Still~We~Do~It}{Conclusion}
\label{chap5}
\begin{tikzpicture}[color=black,
                   transform shape,
                   every node/.style={inner sep=0pt}]
\node[minimum width=\framesize, minimum height=0.45 *\framesize, fill=white](vecbox){};
\node[anchor=north west] at (vecbox.north west){% 
\pgfornament[width=0.1*\framesize]{61}};
\node[anchor=north east] at (vecbox.north east){% 
\pgfornament[width=0.1*\framesize,symmetry=v]{61}};
\node[anchor=south west] at (vecbox.south west){% 
\pgfornament[width=0.1*\framesize,symmetry=h]{61}};
\node[anchor=south east] at (vecbox.south east){% 
\pgfornament[width=0.1*\framesize,symmetry=c]{61}};
\node[anchor=north] at (vecbox.north){% 
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
};

\node[anchor=south] at (vecbox.south){% 
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
\pgfornament[width=0.25*\framesize]{88}
};
\node[text width=0.85\framesize, align=justify] at (vecbox.center){%
The bird with the thorn in its breast, it follows an immutable law; it is driven by it knows not what to impale itself, and die singing. At the very instant the thorn enters there is no awareness in it of the dying to come; it simply sings and sings until there is not the life left to utter another note. But we, when we put the thorns in our breasts, we know. We understand. And still we do it. Still we do it.\\ 
\rightline{--- Colleen McCullough ``The Thorn Birds"}};
\end{tikzpicture}
% I might think about a better title
% I think this title is good enough
\lettrine{T}{hroughout} this thesis, three conceptual questions have been addressed via three studies presented in chapter~\ref{chap2}, chapter~\ref{chap3}, and chapter~\ref{chap4}, ultimately, they all relate to the fundamental motivation of my researches concerning the meaning of computer programs --- to design better abstraction for modelling and understanding programs as well as better formal frameworks for reasoning about programs.

The study discussed in chapter~\ref{chap2} is conducted to address the first conceptual question: How to design a better abstraction mechanism that allows programmers to effectively express \emph{what} they want a computer to do via some declarative yet accurate \emph{specifications} instead of \emph{how} a computer should accomplish a task via some concrete \emph{implementations}? The study specifically focuses on designing property-based container types in programming languages. In particular, we investigate ways to declaratively specify the properties of container types using formal specifications instead of having these properties concretely implemented for container types, allowing concrete implementations to be inferred from the specifications. In this study, we utilise existing verification techniques including formal specifications, data refinement, and refinement types for the purpose of designing declarative yet accurate abstractions. We demonstrate that these specifications describing \emph{what} properties, especially properties giving an account of functional requirements that a container type and its operations should satisfy, which are separated from concrete container implementations describing \emph{how} properties are satisfied. In terms of addressing the conceptual question regarding to the understanding of the relationship between specifications and implementations, the design of property based container types in this study indicates that declarative specifications enable better automation and optimisation for application programmers when selecting desired container implementations in programs. 

The study discussed in chapter~\ref{chap3} is conducted to address the second conceptual question: How to intuitively understand \emph{distributed programs} using the same conceptual model as \emph{monolithic programs}? The study focuses on designing, implementing, and formalising a UMI framework as a Rust library. This UMI framework allows a distributed program to be migrated a monolithic program without massive changes to the syntax or structure of the original monolithic program. In addition, the semantics of the monolithic program is preserved. By formalising the core calculus of the UMI framework implemented as a distributed extension of Rust, we argue that our UMI framework extends Rust's memory safety guarantees into a distributed setting by utilising Rust's ownership and lifetime system in distributed memory management. In terms of addressing the conceptual question regarding to understanding the connection between monolithic programs and distributed programs, the UMI framework demonstrates that a monolithic program can be viewed as an abstraction of a distributed program. Rather than requiring programmers to implement \emph{how} some functionalities are achieved in a distributed setting via network communication protocols and message passing, programmers only need to specify \emph{what} these functionalities a distributed program is required to achieve in terms of a monolithic program by abstracting away the details of distributed memory management and message passing over a network.

The study discussed in chapter~\ref{chap4} is conducted to address the third conceptual question: How do we characterise the relationship between the \emph{syntax} and \emph{semantics} of programming languages? The study focuses on a thorough examination of the semantics of a core calculus --- System S --- of a family of strategic rewriting languages that instructs syntactic transformations. More specifically, we formalise a denotational semantics and big-step operational semantics of System S, featuring errors, divergence, and non-determinism. In addition, we prove the equivalence of these two semantic models, showing that they are equally expressive, and model the same meaning of System S. We then present an axiomatic model of System S, which is a weakest precondition calculus, allowing us to reason about the executions of rewrites encoded in System S. Regarding to the conceptual question, this study demonstrate a perhaps interesting observation: As for strategic rewriting languages, the syntax and semantics are interdependent. The syntactic transformations of expressions encode the meaning for the evaluation of these expressions, and by designing and analysing three different formal models of semantics, we are able to characterise and reason about the executions of compositions of these syntactic transformations.

% With respect to the theme of this thesis --- studies concerning the meaning of computer programs, 
There is one important observation shared by all three studies: There is always a tension between the expressiveness and the elegance of abstraction when modelling programming languages. In the first study, we have observed that it is challenging to express performance related non-functional properties for containers using the declarative formal specification we have designed. In the second project, we have presented our UMI framework which provides a conceptual modelling which views a monolithic program as a functional specification of a distributed program, abstracting over the complicated network communication details while extending the memory safety guarantees provided by the monolithic program into a the distributed program. However, such an abstraction is not expressive enough to capture the failures caused by the network communication problems and server errors. In the third project, in order to formalise concise and elegant semantics of the composition of syntactic transformations, we abstract away the detail implementations of the atomic strategies and model them as partial functions. However, such an abstraction is not expressive enough to model concepts such as side effects of the execution of atomic strategies. To summarise such an observation, if the model is too detailed and precise, it may become overly specific and complicated, lose the generality, and obscure the high-level structure of the language features that it models. However, if the model if too abstract, it may lose some important aspects of the language features that it models. When we are designing a formal model to demonstrate some principled understanding of some features we care about in a programming language, we should always consider the balance between expressiveness and abstraction. 

Back to the theme of this thesis --- studies concerning the meaning of computer programs, we have conducted three studies relating to explore better techniques for modelling important features and components of programming languages, including container types, distributed programming, and term rewriting. \begin{highlightnew}We have utilised all three formal semantic techniques in these studies for\end{highlightnew} enabling programmers to gain formal understanding of computer programs, to effectively communicate desired functionalities to computers without being overly specific, and to reason about the executions of computer programs. 

%Specifically, \emph{operational semantics} provides meanings to programs by modelling how computations get executed. In particular, \emph{small-step operational semantics} focuses on the incremental reduction of expressions or states, providing a detailed and precise understanding of program behaviours, while \emph{big-step operational semantics} describes the execution of programs in terms of its overall behaviours or outcomes rather than its individual intermediate execution steps. Operational semantics is particularly useful for the implementation of a programming language. \emph{Denotational semantics} gives meanings to programs by modelling the result of computations as mathematical objects. It abstracts away the details of the execution of programs and gives an elegant mathematical model presenting the core concepts of a programming language. Instead of modelling how computations get executed or what are produced by executions of computations, \emph{axiomatic semantics} provides meanings to programs by specifying properties satisfied by the results produced by executions of computations. In practice, it is particularly useful for building a proof system for reasoning about the execution of programs.

\begin{highlightnew}
As summarised in table~\ref{chap5:summary}, in chapter~\ref{chap2}, specifications we design take the form of axiomatic semantics specifying properties should be maintained by all operations of a container as well as the desired outcome of the execution of each operation defined for a container. By choosing the axiomatic model, although we are not able to express the runtime behaviours (non-functional properties) of the container operations, as this semantic model assigns meanings to programs by specifying properties satisfied by the results produced by executions of computations, we are able to effectively express the properties concerning the functional aspects of container implementation, which is the goal of this study. 

In chapter~\ref{chap3}, we use a small-step operational semantics for formalising the meaning of monolithic and distributed Rust programs, which is good for capturing implementation details. However, such an operational model is not good for abstraction, hence we need to relate the semantics of monolithic programs and the semantics of distributed programs with a relation stated as the location transparency theorem saying that the latter preserves the former. A denotational model could easily establish such a relation by construction as it is able to be instantiated for different runtime structures, however, such a semantic model does not exist for the surface language of Rust. Although using the operational model is a valid approach for this study, perhaps this study still motivates the need of developing an denotational model for the surface language of Rust in the future.

In chapter~\ref{chap4}, 
\end{highlightnew}

\begin{table}[!t]
\caption {A summary of different semantic techniques used in different chapters} \label{chap5:summary} 
\begin{tabular}{ |l|l|l| } 
\hline
\textbf{Operational semantics} & \textbf{Denotational semantics} & \textbf{Axiomatic semantics}  \\\hline
Chapter 3, Chapter 4 & Chapter 4 & Chapter 2, Chapter 4\\
\hline
\end{tabular}
\end{table}


\begin{center}
\vspace{-0.7em}
\pgfornament[width=0.08*\framesize]{11}
\pgfornament[width=0.08*\framesize]{80}
\pgfornament[width=0.08*\framesize]{14}
\vspace{-0.3em}
\end{center}

Everything beautiful will eventually come to an end. Although I have been asking different questions, wondering around different paths, and searching for different angles to gain some understandings of the questions I have been asking, like the bird with the impaling thorn, everything I have been exploring eventually leads to the same direction: I am in the process of searching for the meaning of the world, especially the world of which I am the centre --- and in the end the result might just be: \emph{It is meaningless}. Nevertheless, I know, I understand, even if there is nothing there, still I search for it, till the end of my life, still I search for it.